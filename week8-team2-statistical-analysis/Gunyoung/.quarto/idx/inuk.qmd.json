{"title":"Inuk","markdown":{"yaml":{"title":"Inuk","author":"Inuk Song","date":"2022-08-17"},"headingText":"로지스틱 회귀분석을 통한 뇌졸증 발병 예측","containsRefs":false,"markdown":"\n```{r setup, include=FALSE}\nknitr::opts_chunk$set(echo = FALSE)\nknitr::opts_chunk$set(message = FALSE)\n```\n\n\n    - 데이터 출처: https://www.kaggle.com/datasets/zzettrkalpakbal/full-filled-brain-stroke-dataset\n\n## 1. EDA\n\n### 1-1. 데이터 불러오기\n\n#### 데이터 랜덤으로 섞기\n```{r echo = TRUE, include=FALSE}\nbrain1 <- read.csv(\"../InukSOng/brain_stroke.csv\", header = TRUE)\nbrain2 <- read.csv(\"../InukSOng/brain_stroke_filled.csv\", header = TRUE)\nbrain <- rbind(brain1, brain2)\n```\n\n\n### 1-2. 데이터 정보 확인\n\n#### 데이터 요약\n```{r}\nstr(brain)\n```\n#### 결측치 확인\n```{r}\nsum(is.na(brain))\n```\n#### **dependent variable = stroke 비율 확인**\n```{r}\nprop.table(table(brain$stroke))\n```\n\n### 1-3. 데이터 전처리\n\n#### 범주형데이터 factor로 변경\n```{r}\nindex <- c(1, 3, 4, 5, 6, 7, 10, 11)\nbrain[, index] <- lapply(brain[, index], factor)\nstr(brain)\n```\n\n### 1-4. 데이터 시각화\n\n#### 수치형 데이터 boxplot 그려보기\n```{r}\nlibrary(ggplot2)\nlibrary(dplyr)\nlabel <- c(\"non stroke\", \"stroke\")\nbrain$stroke <- factor(brain$stroke)\n\nggplot(data = brain) +\n    geom_boxplot(\n        mapping = aes(\n            x = stroke, y = age, fill = stroke\n        ),\n        alpha = 0.4, outlier.color = \"red\"\n    ) +\n    geom_jitter(aes(x = stroke, y = age, col = stroke), alpha = 0.1) +\n    theme_bw()\n\nggplot(data = brain) +\n    geom_boxplot(\n        mapping = aes(\n            x = stroke, y = avg_glucose_level, fill = stroke\n        ),\n        alpha = 0.4, outlier.color = \"red\"\n    ) +\n    geom_jitter(aes(x = stroke, y = avg_glucose_level, col = stroke), alpha = 0.1) +\n    theme_bw()\n\nggplot(data = brain) +\n    geom_boxplot(\n        mapping = aes(\n            x = stroke, y = bmi, fill = stroke\n        ),\n        alpha = 0.4, outlier.color = \"red\"\n    ) +\n    geom_jitter(aes(x = stroke, y = bmi, col = stroke), alpha = 0.1) +\n    theme_bw()\n```\n\n#### cdplot으로 밀도 차이 확인\n```{r}\ncdplot(stroke ~ age, data = brain, col = c(\"lightgreen\", \"gray\"), main = \"stroke ~ age\")\ncdplot(stroke ~ avg_glucose_level, data = brain, col = c(\"lightgreen\", \"gray\"), main = \"stroke ~ avg_glucose_level\")\ncdplot(stroke ~ bmi, data = brain, col = c(\"lightgreen\", \"gray\"), main = \"stroke ~ bmi\")\n```\n\n#### mosaicplot으로 stroke와 범주형 데이터 비교\n```{r}\nmosaicplot(stroke ~ hypertension, data = brain, main = \"stroke vs hypertension\", col = c(\"tomato\", \"skyblue\"))\nmosaicplot(stroke ~ heart_disease, data = brain, main = \"stroke vs heart_disease\", col = c(\"tomato\", \"skyblue\"))\n```\n\n## 2. 로지스틱 회귀분석\n\n### 2-1. 모델 생성\n\n#### train, test 데이터 나누기\n```{r echo = TRUE}\nset.seed(1500)\nbrain <- brain[sample(nrow(brain)), ]\nbrain.train <- brain[1:3500, ]\nbrain.test <- brain[3501:5182, ]\n```\n\n#### 로지스틱 모델 생성\n```{r}\nmodel <- glm(stroke ~ ., data = brain.train, family = binomial(link = \"logit\"))\nsummary(model)\n```\n##### odds ratio\n```{r}\nexp(coef(model))\n```\n\n#### stepwise logistic regression 수행\n```{r include= FALSE}\nmodel <- step(model, direction = \"backward\")\n```\n```{r}\nsummary(model)\n```\n##### odds ratio\n```{r}\nodds.ratio <- exp(coef(model))\nodds.ratio\n```\n\n### 2-2. 모델 테스트\n\n#### odds ratio 시각화\n```{r}\nlibrary(moonBook)\nORplot(model,\n    type = 2, show.OR = FALSE, show.CI = TRUE,\n    pch = 15, lwd = 3, col = c(\"blue\", \"red\")\n)\n```\n\n#### 예측테스트(임계값 0.5)\n```{r}\nprobability <- predict(model, brain.train, type = \"response\")\npredict_A <- as.factor(ifelse(probability > 0.5, \"1\", \"0\"))\n```\n\n#### 혼동행렬 확인\n```{r}\nlibrary(caret)\nconfusionMatrix(predict_A, brain.train$stroke)\n```\n\n#### 다중 공산성 확인\n```{r}\nlibrary(car)\nvif(model)\n```\n\n### 2-3. ROC Curve를 통해서 최적의 임계값 구하기\n    - 참고 사이트\n    - https://www.theissaclee.com/post/logistic-regression-beta/\n    - https://www.verywellhealth.com/negative-predictive-value-3132879\n\n#### 방법1. Sensitivity, Specificity\n```{r}\nlibrary(pROC)\nROC <- roc(brain.train$stroke, probability)\nplot.roc(ROC,\n    col = \"royalblue\",\n    print.auc = TRUE,\n    max.auc.polygon = TRUE,\n    print.thres = TRUE, print.thres.pch = 19, print.thres.col = \"red\",\n    auc.polygon = TRUE, auc.polygon.col = \"lightblue\"\n)\n```\n\n#### 방법2. False positive rate, True positive rate \n```{r}\nlibrary(ROCR)\nlibrary(dplyr)\n\nprediction(probability, brain.train$stroke) %>%\n    performance(measure = \"tpr\", x.measure = \"fpr\") -> result\n\nplotdata <- data.frame(\n    x = result@x.values[[1]],\n    y = result@y.values[[1]],\n    p = result@alpha.values[[1]]\n)\n\np <- ggplot(data = plotdata) +\n    geom_path(aes(x = x, y = y)) +\n    xlab(result@x.name) +\n    ylab(result@y.name) +\n    theme_bw()\n\ndist_vec <- plotdata$x^2 + (1 - plotdata$y)^2\nopt_pos <- which.min(dist_vec)\n\np +\n    geom_point(\n        data = plotdata[opt_pos, ],\n        aes(x = x, y = y), col = \"red\"\n    ) +\n    annotate(\"text\",\n        x = plotdata[opt_pos, ]$x + 0.1,\n        y = plotdata[opt_pos, ]$y,\n        label = paste(\"p =\", round(plotdata[opt_pos, ]$p, 3))\n    )\n\nmin_pos <- which.max(plotdata$y >= 0.85)\n\np +\n    geom_point(\n        data = plotdata[plotdata$y >= 0.85, ],\n        aes(x = x, y = y), size = 0.2, col = \"green\"\n    ) +\n    geom_hline(yintercept = 0.85, linetype = \"dashed\") +\n    geom_point(data = plotdata[min_pos, ], aes(x = x, y = y), col = \"red\") +\n    annotate(\"text\",\n        x = plotdata[min_pos, ]$x + 0.07,\n        y = plotdata[min_pos, ]$y - 0.02,\n        label = paste(\"p =\", round(plotdata[min_pos, ]$p, 3)),\n        col = \"red\"\n    ) +\n    geom_point(\n        data = plotdata[opt_pos, ],\n        aes(x = x, y = y), col = \"black\"\n    ) +\n    annotate(\"text\",\n        x = plotdata[opt_pos, ]$x + 0.05,\n        y = plotdata[opt_pos, ]$y - 0.05,\n        label = paste(\"p =\", round(plotdata[opt_pos, ]$p, 3))\n    )\n```\n\n#### 새로운 임계값으로 예측값 확인\n```{r}\npredict_C <- as.factor(ifelse(probability > 0.049, \"1\", \"0\"))\nconfusionMatrix(predict_C, brain.train$stroke)\n```\n\n\n### 2-4. 만든 모델로 test데이터 예측\n```{r}\nprobability_test <- predict(model, brain.test, type = \"response\")\npredict_test <- as.factor(ifelse(probability_test > 0.049, \"1\", \"0\"))\nconfusionMatrix(predict_test, brain.test$stroke)\n```\n\n"},"formats":{"html":{"execute":{"fig-width":7,"fig-height":5,"fig-format":"retina","fig-dpi":96,"df-print":"default","error":false,"eval":true,"cache":null,"freeze":false,"echo":true,"output":true,"warning":true,"include":true,"keep-md":false,"keep-ipynb":false,"ipynb":null,"enabled":null,"daemon":null,"daemon-restart":false,"debug":false,"ipynb-filters":[],"engine":"knitr"},"render":{"keep-tex":false,"keep-yaml":false,"keep-source":false,"keep-hidden":false,"prefer-html":false,"output-divs":true,"output-ext":"html","fig-align":"default","fig-pos":null,"fig-env":null,"code-fold":"none","code-overflow":"scroll","code-link":false,"code-line-numbers":false,"code-tools":false,"tbl-colwidths":"auto","merge-includes":true,"latex-auto-mk":true,"latex-auto-install":true,"latex-clean":true,"latex-max-runs":10,"latex-makeindex":"makeindex","latex-makeindex-opts":[],"latex-tlmgr-opts":[],"latex-input-paths":[],"latex-output-dir":null,"link-external-icon":false,"link-external-newwindow":false,"self-contained-math":false,"format-resources":[]},"pandoc":{"standalone":true,"wrap":"none","default-image-extension":"png","to":"html","css":["style.css"],"output-file":"inuk.html"},"language":{},"metadata":{"lang":"en","fig-responsive":true,"quarto-version":"1.0.38","theme":"cosmo","title":"Inuk","author":"Inuk Song","date":"2022-08-17"},"extensions":{"book":{"multiFile":true}}}}}